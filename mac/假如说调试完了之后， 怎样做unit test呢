在 CLI + VIM 环境中进行单元测试，这里有一套完整的方案：

1. 配置测试环境

Gradle 配置（build.gradle.kts）

```kotlin
plugins {
    kotlin("jvm") version "1.9.0"
    id("org.springframework.boot") version "3.1.5"
    kotlin("plugin.spring") version "1.9.0"
}

dependencies {
    // 测试依赖
    testImplementation("org.springframework.boot:spring-boot-starter-test")
    testImplementation("org.junit.jupiter:junit-jupiter:5.9.3")
    testImplementation("io.mockk:mockk:1.13.5")  // Kotlin 友好的 Mock 库
    testImplementation("com.ninja-squad:springmockk:4.0.2")  // Spring + Mockk 集成
    testImplementation("org.jetbrains.kotlin:kotlin-test-junit5")
    testImplementation("org.mybatis.spring.boot:mybatis-spring-boot-starter-test:3.0.2")
}

tasks.test {
    useJUnitPlatform()
    testLogging {
        events("passed", "failed", "skipped")
        showStandardStreams = true
    }
}
```

2. 测试文件结构和命名

推荐结构

```
src/test/kotlin/com/example/demo/
├── service/
│   ├── UserServiceTest.kt
│   ├── ProductServiceTest.kt
│   └── assertions/          # 自定义断言
│       └── UserAssertions.kt
├── mapper/
│   ├── UserMapperTest.kt
│   └── MybatisTestConfig.kt
├── controller/
│   └── UserControllerTest.kt
├── util/
│   └── TestDataFactory.kt   # 测试数据工厂
└── integration/             # 集成测试
    └── UserIntegrationTest.kt
```

命名规范

```kotlin
// Service 测试
class UserServiceTest

// 使用 describe/context/it 风格（可选）
class UserServiceSpec : DescribeSpec({
    describe("用户服务") {
        context("当用户存在时") {
            it("应该返回用户信息") {
                // 测试逻辑
            }
        }
    }
})
```

3. Service 层单元测试示例

基础测试模板

```kotlin
package com.example.demo.service

import io.mockk.every
import io.mockk.mockk
import io.mockk.verify
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.BeforeEach

class UserServiceTest {
    
    private lateinit var userRepository: UserRepository
    private lateinit var emailService: EmailService
    private lateinit var userService: UserService
    
    @BeforeEach
    fun setUp() {
        userRepository = mockk()
        emailService = mockk()
        userService = UserService(userRepository, emailService)
    }
    
    @Test
    fun `getUserById should return user when user exists`() {
        // Given
        val userId = 1L
        val expectedUser = User(id = userId, name = "John", email = "john@test.com")
        
        every { userRepository.findById(userId) } returns expectedUser
        
        // When
        val result = userService.getUserById(userId)
        
        // Then
        assertNotNull(result)
        assertEquals(userId, result!!.id)
        assertEquals("John", result.name)
        
        verify(exactly = 1) { userRepository.findById(userId) }
    }
    
    @Test
    fun `getUserById should return null when user not exists`() {
        // Given
        val userId = 999L
        every { userRepository.findById(userId) } returns null
        
        // When
        val result = userService.getUserById(userId)
        
        // Then
        assertNull(result)
        verify { userRepository.findById(userId) }
    }
    
    @Test
    fun `createUser should save user and send welcome email`() {
        // Given
        val request = CreateUserRequest(name = "Alice", email = "alice@test.com")
        val savedUser = User(id = 1L, name = "Alice", email = "alice@test.com")
        
        every { userRepository.save(any()) } returns savedUser
        every { emailService.sendWelcomeEmail(any()) } returns Unit
        
        // When
        val result = userService.createUser(request)
        
        // Then
        assertEquals(1L, result.id)
        assertEquals("Alice", result.name)
        
        verify { 
            userRepository.save(match { 
                it.name == "Alice" && it.email == "alice@test.com" 
            }) 
        }
        verify { emailService.sendWelcomeEmail(savedUser.email) }
    }
}
```

4. MyBatis Mapper 测试

配置测试数据库

```kotlin
// src/test/resources/application-test.yml
spring:
  datasource:
    url: jdbc:h2:mem:testdb;MODE=MySQL;DB_CLOSE_DELAY=-1
    driver-class-name: org.h2.Driver
    username: sa
    password: 
  sql:
    init:
      schema-locations: classpath:schema-test.sql
      data-locations: classpath:data-test.sql

mybatis:
  mapper-locations: classpath:mapper/*.xml
```

Mapper 测试类

```kotlin
package com.example.demo.mapper

import org.mybatis.spring.boot.test.autoconfigure.MybatisTest
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.boot.test.autoconfigure.jdbc.AutoConfigureTestDatabase
import org.springframework.test.context.TestPropertySource
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.Assertions.*

@MybatisTest
@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)
@TestPropertySource(properties = ["spring.config.location=classpath:application-test.yml"])
class UserMapperTest {
    
    @Autowired
    private lateinit var userMapper: UserMapper
    
    @Test
    fun `findById should return user when exists`() {
        // Given - 数据在 data-test.sql 中已准备
        val userId = 1L
        
        // When
        val user = userMapper.findById(userId)
        
        // Then
        assertNotNull(user)
        assertEquals("测试用户", user?.name)
    }
    
    @Test
    fun `insert should save user and return generated id`() {
        // Given
        val user = User(name = "新用户", email = "new@test.com")
        
        // When
        val rows = userMapper.insert(user)
        
        // Then
        assertEquals(1, rows)
        assertNotNull(user.id)  // MyBatis 会回填生成的 ID
        
        // 验证是否真的保存了
        val savedUser = userMapper.findById(user.id!!)
        assertEquals("新用户", savedUser?.name)
    }
    
    @Test
    fun `findAll should return all users`() {
        // When
        val users = userMapper.findAll()
        
        // Then
        assertTrue(users.isNotEmpty())
    }
}
```

5. Controller 层测试

使用 @WebMvcTest

```kotlin
package com.example.demo.controller

import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper
import io.mockk.every
import io.mockk.mockk
import org.junit.jupiter.api.Test
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest
import org.springframework.boot.test.mock.mockito.MockBean
import org.springframework.http.MediaType
import org.springframework.test.web.servlet.MockMvc
import org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*
import org.springframework.test.web.servlet.result.MockMvcResultMatchers.*

@WebMvcTest(UserController::class)
class UserControllerTest {
    
    @Autowired
    private lateinit var mockMvc: MockMvc
    
    @MockBean
    private lateinit var userService: UserService
    
    private val objectMapper = jacksonObjectMapper()
    
    @Test
    fun `GET /api/users/{id} should return user`() {
        // Given
        val userId = 1L
        val user = UserDTO(id = userId, name = "John", email = "john@test.com")
        
        every { userService.getUserById(userId) } returns user
        
        // When & Then
        mockMvc.perform(get("/api/users/{id}", userId))
            .andExpect(status().isOk)
            .andExpect(jsonPath("$.id").value(userId))
            .andExpect(jsonPath("$.name").value("John"))
            .andExpect(jsonPath("$.email").value("john@test.com"))
    }
    
    @Test
    fun `POST /api/users should create user`() {
        // Given
        val request = CreateUserRequest(name = "Alice", email = "alice@test.com")
        val response = UserDTO(id = 1L, name = "Alice", email = "alice@test.com")
        
        every { userService.createUser(any()) } returns response
        
        // When & Then
        mockMvc.perform(
            post("/api/users")
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(request))
        )
            .andExpect(status().isCreated)
            .andExpect(header().string("Location", "/api/users/1"))
            .andExpect(jsonPath("$.id").value(1L))
            .andExpect(jsonPath("$.name").value("Alice"))
    }
    
    @Test
    fun `GET /api/users/{id} should return 404 when user not found`() {
        // Given
        val userId = 999L
        every { userService.getUserById(userId) } returns null
        
        // When & Then
        mockMvc.perform(get("/api/users/{id}", userId))
            .andExpect(status().isNotFound)
    }
}
```

6. 测试数据管理

测试数据工厂

```kotlin
package com.example.demo.util

import com.example.demo.service.dto.*

object TestDataFactory {
    
    fun createUser(
        id: Long = 1L,
        name: String = "Test User",
        email: String = "test@example.com"
    ): UserDTO = UserDTO(
        id = id,
        name = name,
        email = email
    )
    
    fun createUserRequest(
        name: String = "New User",
        email: String = "new@example.com"
    ): CreateUserRequest = CreateUserRequest(
        name = name,
        email = email
    )
    
    fun createUsers(count: Int): List<UserDTO> =
        (1..count).map { createUser(id = it.toLong(), name = "User $it") }
}
```

数据库测试数据

```sql
-- src/test/resources/schema-test.sql
CREATE TABLE IF NOT EXISTS users (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    email VARCHAR(255) NOT NULL UNIQUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- src/test/resources/data-test.sql
INSERT INTO users (id, name, email) VALUES
(1, '测试用户1', 'test1@example.com'),
(2, '测试用户2', 'test2@example.com'),
(3, '测试用户3', 'test3@example.com');
```

7. 在 CLI 中运行测试

常用测试命令

```bash
# 1. 运行所有测试
./gradlew test

# 2. 运行特定测试类
./gradlew test --tests "*UserServiceTest"

# 3. 运行特定测试方法
./gradlew test --tests "*UserServiceTest.getUserById should return user when user exists"

# 4. 运行指定包下的测试
./gradlew test --tests "com.example.demo.service.*"

# 5. 失败后继续运行其他测试
./gradlew test --continue

# 6. 重新运行失败的测试
./gradlew test --rerun-tasks

# 7. 生成测试报告
./gradlew test
open build/reports/tests/test/index.html

# 8. 在 VIM 中运行当前文件测试
:!./gradlew test --tests "%:t:r"
```

监听模式（自动运行测试）

```bash
# 安装 gradle 监听插件
./gradlew --build-cache --continuous test

# 或使用 fswatch（macOS/Linux）
fswatch -o src/ | xargs -n1 -I{} ./gradlew test

# 在 VIM 中自动保存时运行测试
autocmd BufWritePost *.kt :!./gradlew test --tests "%:t:r" 2>&1 | tail -20
```

8. VIM 测试集成

配置 VIM 测试运行器

```vim
" ~/.vimrc
Plug 'janko/vim-test'

" 配置测试运行器
let test#strategy = "neoterm"
let test#kotlin#gradletest#options = '--info'

" 快捷键
nmap <silent> <leader>tn :TestNearest<CR>
nmap <silent> <leader>tf :TestFile<CR>
nmap <silent> <leader>ts :TestSuite<CR>
nmap <silent> <leader>tl :TestLast<CR>
nmap <silent> <leader>tv :TestVisit<CR>

" 自定义测试命令
function! RunKotlinTest()
    let test_class = expand('%:t:r')
    execute '!./gradlew test --tests "com.example.demo.*.' . test_class . '"'
endfunction

nnoremap <leader>tt :call RunKotlinTest()<CR>
```

在 VIM 中查看测试结果

```bash
# 使用终端分屏
tmux split-window -h
# 左屏：VIM 编辑代码
# 右屏：运行测试监视
watch -n 2 './gradlew test --tests "*UserServiceTest" 2>&1 | tail -30'
```

9. 测试最佳实践

测试金字塔原则

```kotlin
// 70% 单元测试（快速、隔离）
class UserServiceTest
class UserMapperTest

// 20% 集成测试
@SpringBootTest
class UserIntegrationTest

// 10% 端到端测试
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
class UserE2ETest
```

测试命名规范

```kotlin
// 使用 should 描述行为
@Test
fun `should return user when user exists`()

// 使用 when/then 结构
@Test
fun `when user exists then return user`()

// 使用 given/when/then 注释
@Test
fun `getUserById_withExistingUser_returnsUser`() {
    // given
    // when  
    // then
}
```

测试覆盖率检查

```bash
# 生成覆盖率报告
./gradlew test jacocoTestReport

# 查看覆盖率
open build/reports/jacoco/test/html/index.html

# 在 Gradle 中添加配置
plugins {
    id("jacoco")
}

jacoco {
    toolVersion = "0.8.9"
}

tasks.jacocoTestReport {
    reports {
        xml.required.set(true)
        html.required.set(true)
    }
}
```

10. 调试失败的测试

```bash
# 1. 查看详细测试输出
./gradlew test --info
./gradlew test --debug

# 2. 只运行特定测试并打印日志
./gradlew test --tests "*UserServiceTest" --info 2>&1 | grep -A5 -B5 "FAILED"

# 3. 使用 JUnit 的测试监听器
./gradlew test -Dtest.output=always

# 4. 在 VIM 中查看测试日志
:vsplit build/reports/tests/test/classes/com.example.demo.UserServiceTest.html
```

快速开始模板

创建一个新测试的脚本

```bash
#!/bin/bash
# create_test.sh
if [ -z "$1" ]; then
    echo "Usage: ./create_test.sh <ClassName>"
    exit 1
fi

CLASS_NAME=$1
PACKAGE_PATH=$(find src/main/kotlin -name "${CLASS_NAME}.kt" | head -1 | sed 's|src/main/kotlin/||' | sed 's|/[^/]*$||' | tr '/' '.')
TEST_PATH="src/test/kotlin/${PACKAGE_PATH//./\/}/${CLASS_NAME}Test.kt"

cat > "$TEST_PATH" << EOF
package ${PACKAGE_PATH}

import io.mockk.every
import io.mockk.mockk
import io.mockk.verify
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.BeforeEach

class ${CLASS_NAME}Test {
    
    @BeforeEach
    fun setUp() {
        // 初始化代码
    }
    
    @Test
    fun \`example test\`() {
        // Given
        
        // When
        
        // Then
        assertTrue(true)
    }
}
EOF

echo "Created test: $TEST_PATH"
```

使用方式：

```bash
./create_test.sh UserService
```

这样你就可以在 CLI + VIM 环境中高效地进行单元测试了！需要我详细说明某个特定场景的测试吗？

