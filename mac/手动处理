å‘½ä»¤è¡Œæ‰¹é‡è¿ç§» Data Class åˆ° Entity æ–‡ä»¶

æ˜¯çš„ï¼Œå®Œå…¨å¯ä»¥ä½¿ç”¨å‘½ä»¤è¡Œå·¥å…·æ¥æ‰¹é‡å¤„ç†ï¼æ‰‹åŠ¨å¤„ç†ç¡®å®ç¹çä¸”å®¹æ˜“å‡ºé”™ã€‚è¿™é‡Œä¸ºä½ æä¾›å®Œæ•´çš„è‡ªåŠ¨åŒ–æ–¹æ¡ˆï¼š

ğŸ“ é¡¹ç›®ç»“æ„ç¤ºä¾‹

```
src/main/kotlin/com/example/
â”œâ”€â”€ service/
â”‚   â”œâ”€â”€ UserService.kt    # åŒ…å« data class UserDto
â”‚   â”œâ”€â”€ ProductService.kt # åŒ…å« data class ProductDto
â”‚   â””â”€â”€ OrderService.kt   # åŒ…å« data class OrderDto
â””â”€â”€ entity/              # ç›®æ ‡ç›®å½•
    â””â”€â”€ models.kt        # ç»Ÿä¸€å­˜æ”¾æ‰€æœ‰ data class
```

ğŸ”§ å®Œæ•´è‡ªåŠ¨åŒ–è„šæœ¬

1. æŸ¥æ‰¾æ‰€æœ‰ Data Class å¹¶æå–

```bash
#!/bin/bash
# extract_data_classes.sh

# è®¾ç½®è·¯å¾„
PROJECT_ROOT="/path/to/your/project"
SRC_DIR="$PROJECT_ROOT/src/main/kotlin"
ENTITY_DIR="$SRC_DIR/com/example/entity"
OUTPUT_FILE="$ENTITY_DIR/Models.kt"

# 1. åˆ›å»ºç›®æ ‡æ–‡ä»¶å¤´éƒ¨
cat > "$OUTPUT_FILE" << 'HEADER'
package com.example.entity

import java.time.LocalDateTime
import com.fasterxml.jackson.annotation.JsonProperty

// ==================== è‡ªåŠ¨ç”Ÿæˆçš„ Data Classes ====================

HEADER

# 2. æŸ¥æ‰¾æ‰€æœ‰ Kotlin æ–‡ä»¶ä¸­çš„ data class
find "$SRC_DIR" -name "*.kt" -type f | while read -r file; do
    # è·³è¿‡ entity ç›®å½•è‡ªèº«
    if [[ "$file" == *"/entity/"* ]]; then
        continue
    fi
    
    # æå–æ–‡ä»¶åï¼ˆä¸å¸¦è·¯å¾„å’Œæ‰©å±•åï¼‰
    filename=$(basename "$file" .kt)
    
    # æå–åŒ…å
    package_name=$(grep -oP '^package\s+\K[^\s]+' "$file" || echo "unknown")
    
    # æŸ¥æ‰¾å¹¶æå– data class
    awk -v filename="$filename" -v package="$package_name" '
    /^data class/ {
        in_data_class=1
        indent=""
        buffer=$0
        brace_count=0
        
        # ç»Ÿè®¡ç¬¬ä¸€è¡Œçš„èŠ±æ‹¬å·
        if (index($0, "{")) {
            brace_count += gsub(/{/, "&", $0)
            if (index($0, "}")) {
                brace_count -= gsub(/}/, "&", $0)
            }
        }
        
        next
    }
    
    in_data_class {
        buffer=buffer "\n" $0
        
        # ç»Ÿè®¡èŠ±æ‹¬å·
        brace_count += gsub(/{/, "&", $0)
        brace_count -= gsub(/}/, "&", $0)
        
        # å¦‚æœèŠ±æ‹¬å·å¹³è¡¡ï¼Œè¯´æ˜ data class ç»“æŸ
        if (brace_count == 0) {
            # æ·»åŠ æºæ–‡ä»¶æ³¨é‡Š
            print "// From: " filename " (" package ")"
            print buffer
            print ""
            
            in_data_class=0
            buffer=""
        }
    }
    ' "$file" >> "$OUTPUT_FILE"
    
done

echo "âœ… Data classes extracted to $OUTPUT_FILE"
```

2. Python æ›´å¼ºå¤§çš„ç‰ˆæœ¬

```python
#!/usr/bin/env python3
# migrate_data_classes.py
import os
import re
from pathlib import Path
from typing import List, Tuple
import shutil

class DataClassMigrator:
    def __init__(self, project_root: str):
        self.project_root = Path(project_root)
        self.src_dir = self.project_root / "src/main/kotlin"
        self.entity_dir = self.src_dir / "com/example/entity"
        self.output_file = self.entity_dir / "Models.kt"
        
        # ç¡®ä¿ç›®å½•å­˜åœ¨
        self.entity_dir.mkdir(parents=True, exist_ok=True)
        
        # æ”¶é›†çš„ imports
        self.all_imports = set()
        self.migration_log = []
    
    def extract_data_classes(self) -> List[Tuple[str, str, str]]:
        """æå–æ‰€æœ‰ data class"""
        data_classes = []
        
        for kotlin_file in self.src_dir.rglob("*.kt"):
            # è·³è¿‡ entity ç›®å½•
            if "entity" in str(kotlin_file):
                continue
            
            content = kotlin_file.read_text(encoding='utf-8')
            package_match = re.search(r'^package\s+(\S+)', content, re.MULTILINE)
            package_name = package_match.group(1) if package_match else "unknown"
            
            # æå– imports
            imports = re.findall(r'^import\s+(\S+)', content, re.MULTILINE)
            self.all_imports.update(imports)
            
            # ä½¿ç”¨æ­£åˆ™æå– data classï¼ˆæ”¯æŒå¤šè¡Œï¼‰
            pattern = re.compile(r'^data class\s+\w+\s*\([^)]*\)\s*(?:\{[^}]*\})?', re.MULTILINE | re.DOTALL)
            
            matches = pattern.findall(content)
            for match in matches:
                # æå–ç±»å
                class_name_match = re.search(r'data class\s+(\w+)', match)
                if class_name_match:
                    class_name = class_name_match.group(1)
                    data_classes.append((class_name, match, str(kotlin_file)))
                    
                    # è®°å½•è¿ç§»ä¿¡æ¯
                    self.migration_log.append({
                        'class': class_name,
                        'source_file': str(kotlin_file),
                        'package': package_name
                    })
        
        return data_classes
    
    def create_unified_file(self, data_classes: List[Tuple[str, str, str]]):
        """åˆ›å»ºç»Ÿä¸€çš„ Entity æ–‡ä»¶"""
        header = """package com.example.entity

// ==================== AUTO-GENERATED DATA CLASSES ====================
// DO NOT EDIT THIS FILE MANUALLY
// Generated by migrate_data_classes.py

"""
        
        # æ·»åŠ å¿…è¦çš„ imports
        required_imports = [
            'java.time.LocalDateTime',
            'java.math.BigDecimal',
            'javax.persistence.*',
            'com.fasterxml.jackson.annotation.*'
        ]
        
        imports_section = "\n".join(sorted(self.all_imports)) + "\n\n"
        imports_section += "\n".join(f"import {imp}" for imp in required_imports if any(keyword in str(self.all_imports) for keyword in ['LocalDateTime', 'BigDecimal'])) + "\n\n"
        
        # æ„å»ºå†…å®¹
        content_parts = []
        
        for i, (class_name, data_class, source_file) in enumerate(data_classes):
            # æ·»åŠ æ³¨é‡Šè¯´æ˜æ¥æº
            rel_path = os.path.relpath(source_file, self.src_dir)
            content_parts.append(f"// {'='*60}")
            content_parts.append(f"// From: {rel_path}")
            content_parts.append(f"// {'='*60}\n")
            content_parts.append(data_class)
            
            if i < len(data_classes) - 1:
                content_parts.append("\n\n")
        
        # å†™å…¥æ–‡ä»¶
        full_content = header + imports_section + "".join(content_parts)
        self.output_file.write_text(full_content, encoding='utf-8')
        
        print(f"âœ… Created unified file: {self.output_file}")
        print(f"ğŸ“Š Migrated {len(data_classes)} data classes")
    
    def remove_data_classes_from_source(self):
        """ä»åŸæ–‡ä»¶ä¸­ç§»é™¤ data classï¼ˆå¯é€‰ï¼‰"""
        backup_dir = self.project_root / "backup_data_classes"
        backup_dir.mkdir(exist_ok=True)
        
        for kotlin_file in self.src_dir.rglob("*.kt"):
            if "entity" in str(kotlin_file) or kotlin_file.name == "Models.kt":
                continue
            
            content = kotlin_file.read_text(encoding='utf-8')
            
            # å¤‡ä»½åŸæ–‡ä»¶
            backup_file = backup_dir / kotlin_file.relative_to(self.src_dir)
            backup_file.parent.mkdir(parents=True, exist_ok=True)
            shutil.copy2(kotlin_file, backup_file)
            
            # ç§»é™¤ data class
            pattern = re.compile(r'^\s*data class\s+\w+\s*\([^)]*\)\s*(?:\{[^}]*\})?\s*\n?', re.MULTILINE | re.DOTALL)
            new_content = pattern.sub('', content)
            
            # æ¸…ç†å¤šä½™çš„ç©ºè¡Œ
            new_content = re.sub(r'\n\s*\n\s*\n', '\n\n', new_content)
            
            if new_content != content:
                kotlin_file.write_text(new_content, encoding='utf-8')
                print(f"ğŸ”„ Cleaned: {kotlin_file.relative_to(self.src_dir)}")
    
    def update_imports_in_services(self):
        """æ›´æ–° Service ä¸­çš„å¯¼å…¥è¯­å¥"""
        for kotlin_file in self.src_dir.rglob("*.kt"):
            if "service" not in str(kotlin_file).lower():
                continue
            
            content = kotlin_file.read_text(encoding='utf-8')
            
            # æ›¿æ¢ imports
            for log_entry in self.migration_log:
                class_name = log_entry['class']
                old_package = log_entry['package']
                
                # æŸ¥æ‰¾å¹¶æ›¿æ¢ import
                old_import = f"import {old_package}.{class_name}"
                new_import = f"import com.example.entity.{class_name}"
                
                if old_import in content:
                    content = content.replace(old_import, new_import)
                    print(f"ğŸ“ Updated import in {kotlin_file.name}: {class_name}")
            
            # å†™å…¥æ›´æ–°åçš„æ–‡ä»¶
            kotlin_file.write_text(content, encoding='utf-8')
    
    def generate_report(self):
        """ç”Ÿæˆè¿ç§»æŠ¥å‘Š"""
        report_file = self.project_root / "migration_report.md"
        
        report = f"""# Data Class Migration Report

## Summary
- Total data classes migrated: {len(self.migration_log)}
- Destination file: `{self.output_file.relative_to(self.project_root)}`
- Timestamp: {__import__('datetime').datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

## Migrated Classes

| Class Name | Source File | Original Package |
|------------|-------------|------------------|
"""
        
        for log_entry in self.migration_log:
            report += f"| {log_entry['class']} | {log_entry['source_file']} | {log_entry['package']} |\n"
        
        report_file.write_text(report, encoding='utf-8')
        print(f"ğŸ“‹ Report generated: {report_file}")

def main():
    # é…ç½®é¡¹ç›®æ ¹ç›®å½•
    project_root = input("Enter project root path: ").strip() or "."
    
    migrator = DataClassMigrator(project_root)
    
    print("ğŸ” Scanning for data classes...")
    data_classes = migrator.extract_data_classes()
    
    if not data_classes:
        print("âŒ No data classes found!")
        return
    
    print(f"ğŸ“¦ Found {len(data_classes)} data classes")
    
    # åˆ›å»ºç»Ÿä¸€çš„ Entity æ–‡ä»¶
    migrator.create_unified_file(data_classes)
    
    # è¯¢é—®æ˜¯å¦ä»åŸæ–‡ä»¶ç§»é™¤
    remove_choice = input("\nâ“ Remove data classes from source files? (y/n): ").strip().lower()
    if remove_choice == 'y':
        migrator.remove_data_classes_from_source()
    
    # è¯¢é—®æ˜¯å¦æ›´æ–° imports
    update_imports = input("\nâ“ Update imports in service files? (y/n): ").strip().lower()
    if update_imports == 'y':
        migrator.update_imports_in_services()
    
    # ç”ŸæˆæŠ¥å‘Š
    migrator.generate_report()
    
    print("\nğŸ‰ Migration completed!")
    print("\nâš ï¸  Next steps:")
    print("1. Review the generated Models.kt file")
    print("2. Fix any compilation errors")
    print("3. Run tests to ensure everything works")
    print("4. Check the migration_report.md for details")

if __name__ == "__main__":
    main()
```

ğŸš€ ä¸€é”®æ‰§è¡Œè„šæœ¬

ç®€åŒ–ç‰ˆä¸€é”®è„šæœ¬

```bash
#!/bin/bash
# quick_migrate.sh

set -e  # é‡åˆ°é”™è¯¯é€€å‡º

echo "ğŸš€ Starting data class migration..."

# 1. å¤‡ä»½å½“å‰çŠ¶æ€
echo "ğŸ“¦ Creating backup..."
timestamp=$(date +%Y%m%d_%H%M%S)
backup_dir="backup_$timestamp"
mkdir -p "$backup_dir"
cp -r src/ "$backup_dir/src_backup/"
echo "âœ… Backup created: $backup_dir"

# 2. è¿è¡Œ Python è¿ç§»è„šæœ¬
python3 migrate_data_classes.py

# 3. ç¼–è¯‘æ£€æŸ¥
echo "ğŸ”§ Checking compilation..."
if command -v gradle &> /dev/null; then
    if gradle compileKotlin; then
        echo "âœ… Compilation successful"
    else
        echo "âŒ Compilation failed, restoring backup..."
        cp -r "$backup_dir/src_backup/" src/
        echo "ğŸ“¤ Backup restored from $backup_dir"
        exit 1
    fi
fi

echo "ğŸ‰ Migration completed successfully!"
echo "ğŸ“‹ Check migration_report.md for details"
```

å®‰å…¨çš„åˆ†æ­¥æ“ä½œ

```bash
# æ­¥éª¤1: ä»…æå–ï¼Œä¸ä¿®æ”¹åŸæ–‡ä»¶
python3 migrate_data_classes.py --dry-run

# æ­¥éª¤2: æŸ¥çœ‹å°†è¦è¿ç§»çš„å†…å®¹
python3 migrate_data_classes.py --preview

# æ­¥éª¤3: æ‰§è¡Œè¿ç§»ï¼ˆå¸¦å¤‡ä»½ï¼‰
python3 migrate_data_classes.py --execute --backup

# æ­¥éª¤4: éªŒè¯ç¼–è¯‘
./gradlew compileKotlin --info

# æ­¥éª¤5: è¿è¡Œæµ‹è¯•
./gradlew test --tests "*Service*"
```

ğŸ” å¤„ç†å¯¼å…¥åŒ…çš„æ­£ç¡®æ–¹æ³•

è‡ªåŠ¨æ›´æ–°å¯¼å…¥çš„è„šæœ¬

```python
# update_imports.py
import os
import re

def update_all_imports(project_root: str):
    """æ›´æ–°æ‰€æœ‰æ–‡ä»¶ä¸­çš„å¯¼å…¥è¯­å¥"""
    
    # æ‰«ææ‰€æœ‰æ–‡ä»¶ï¼Œæ”¶é›†ç±»çš„åŸå§‹ä½ç½®
    class_locations = {}
    for root, dirs, files in os.walk(os.path.join(project_root, "src")):
        for file in files:
            if file.endswith(".kt"):
                filepath = os.path.join(root, file)
                with open(filepath, 'r', encoding='utf-8') as f:
                    content = f.read()
                
                # æŸ¥æ‰¾ data class å®šä¹‰
                matches = re.finditer(r'data class (\w+)', content)
                for match in matches:
                    class_name = match.group(1)
                    # æå–åŒ…å
                    package_match = re.search(r'^package\s+(\S+)', content, re.MULTILINE)
                    if package_match:
                        full_class = f"{package_match.group(1)}.{class_name}"
                        class_locations[class_name] = full_class
    
    # æ›´æ–°æ‰€æœ‰æ–‡ä»¶ä¸­çš„å¯¼å…¥
    for root, dirs, files in os.walk(os.path.join(project_root, "src")):
        for file in files:
            if file.endswith(".kt"):
                filepath = os.path.join(root, file)
                with open(filepath, 'r', encoding='utf-8') as f:
                    content = f.read()
                
                updated = False
                for class_name, old_full_class in class_locations.items():
                    new_import = f"import com.example.entity.{class_name}"
                    
                    # æ›¿æ¢å…·ä½“çš„å¯¼å…¥
                    content = re.sub(
                        rf'^import\s+{re.escape(old_full_class)}\s*$',
                        new_import,
                        content,
                        flags=re.MULTILINE
                    )
                    
                    # æ›¿æ¢åŒ…å†…çš„ä½¿ç”¨ï¼ˆç®€å•ç±»å‹ï¼‰
                    content = re.sub(
                        rf'\b{re.escape(class_name)}\b',
                        f"com.example.entity.{class_name}",
                        content
                    )
                
                if updated:
                    with open(filepath, 'w', encoding='utf-8') as f:
                        f.write(content)
                    print(f"Updated: {filepath}")
```

ğŸ“‹ ç¼ºå°‘çš„æ­¥éª¤å’Œæ³¨æ„äº‹é¡¹

ä½ å¯èƒ½ç¼ºå°‘çš„æ­¥éª¤ï¼š

1. ä¾èµ–å…³ç³»æ£€æŸ¥ï¼š
   ```bash
   # æ£€æŸ¥å“ªäº›ç±»è¢«å“ªäº›æ–‡ä»¶å¼•ç”¨
   grep -r "UserDto" src/ --include="*.kt"
   ```
2. æ„å»ºç¼“å­˜æ¸…ç†ï¼š
   ```bash
   ./gradlew clean
   ```
3. å¤„ç†å†…éƒ¨ä¾èµ–ï¼š
   ```python
   # å¦‚æœ data class ä¹‹é—´æœ‰ç›¸äº’å¼•ç”¨
   data class User(val id: Long, val profile: Profile)  # Profile ä¹Ÿéœ€è¦è¿ç§»
   data class Profile(val userId: Long, val info: String)
   ```
4. å¤„ç†æ³›å‹å’Œå¤æ‚ç±»å‹ï¼š
   ```kotlin
   data class ApiResponse<T>(val data: T, val status: String)
   ```

æ¨èçš„å·¥ä½œæµç¨‹ï¼š

```bash
# 1. å¤‡ä»½
cp -r src/ src_backup/

# 2. æå–åˆ°ä¸´æ—¶æ–‡ä»¶æŸ¥çœ‹
python3 migrate_data_classes.py --output temp/Models.kt

# 3. æ‰‹åŠ¨æ£€æŸ¥ä¸´æ—¶æ–‡ä»¶
cat temp/Models.kt | head -50

# 4. æ­£å¼è¿ç§»
python3 migrate_data_classes.py --execute

# 5. ä¿®å¤å¯¼å…¥ï¼ˆåŠè‡ªåŠ¨ï¼‰
python3 update_imports.py

# 6. ç¼–è¯‘æµ‹è¯•
./gradlew compileKotlin

# 7. è¿è¡Œå…³é”®æµ‹è¯•
./gradlew test --tests "*UserServiceTest"
```

é£é™©æç¤ºï¼š

1. åŒåç±»å†²çªï¼šä¸åŒåŒ…çš„åŒå data class
2. è®¿é—®ä¿®é¥°ç¬¦ï¼šinternalã€private ä¿®é¥°ç¬¦
3. æ³¨è§£å¤„ç†ï¼š@JvmStaticã€@Serializable ç­‰
4. ä¼´ç”Ÿå¯¹è±¡ï¼šdata class ä¸­çš„ companion object
5. æ‰©å±•å‡½æ•°ï¼šé’ˆå¯¹ data class çš„æ‰©å±•å‡½æ•°

å»ºè®®å…ˆåœ¨å°èŒƒå›´æµ‹è¯•ï¼Œç¡®è®¤æ— è¯¯åå†å…¨é‡è¿ç§»ï¼

