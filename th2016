这是一个常见的 Thymeleaf 片段重用问题。当在循环中使用相同的片段时，需要注意 ID 唯一性和 JavaScript 作用域。以下是几种解决方案：

1. 使用索引区分元素

1.1 在 Thymeleaf 中传递唯一标识

```html
<div th:each="item, iterStat : ${items}">
    <!-- 使用索引创建唯一ID -->
    <div class="item-container" th:attr="data-index=${iterStat.index}">
        <button th:onclick="'showDetail(' + ${iterStat.index} + ')'"
                class="btn-show-detail">
            显示详情 [[${item.id}]]
        </button>
        
        <!-- 隐藏的详情块，每个都有唯一ID -->
        <div th:id="'detail-block-' + ${iterStat.index}" 
             class="detail-block" 
             style="display: none;">
            <h3>详情: [[${item.name}]]</h3>
            <p>[[${item.description}]]</p>
        </div>
    </div>
</div>
```

2. 使用数据属性（推荐）

2.1 Thymeleaf 模板

```html
<!-- template.html -->
<div th:fragment="itemList">
    <div th:each="item : ${items}" 
         class="item-card"
         th:data-item-id="${item.id}">
        
        <h4 th:text="${item.name}">Item Name</h4>
        <button class="toggle-detail-btn" 
                th:data-target="|detail-${item.id}|">
            显示/隐藏详情
        </button>
        
        <!-- 每个详情块有唯一ID -->
        <div th:id="'detail-' + ${item.id}" 
             class="detail-content"
             style="display: none;">
            <div th:replace="~{fragments/detail :: detailContent(${item})}"></div>
        </div>
    </div>
</div>
```

2.2 详情片段（单独文件）

```html
<!-- fragments/detail.html -->
<div th:fragment="detailContent(item)">
    <div class="detail-panel">
        <h3 th:text="${item.title}">Title</h3>
        <p th:text="${item.description}">Description</p>
        <p th:text="${item.price}">Price</p>
        <!-- 其他详情内容 -->
    </div>
</div>
```

3. JavaScript/TypeScript 处理

3.1 使用事件委托（推荐）

```typescript
// detail-toggle.ts
export class DetailToggle {
    static init(): void {
        // 使用事件委托，避免为每个按钮绑定事件
        document.addEventListener('click', (event) => {
            const target = event.target as HTMLElement;
            
            // 检查是否点击了切换按钮
            if (target.classList.contains('toggle-detail-btn')) {
                const itemId = target.getAttribute('data-target');
                if (itemId) {
                    this.toggleDetail(itemId);
                }
            }
            
            // 或者通过父元素查找
            const button = target.closest('[data-toggle="detail"]');
            if (button) {
                const container = button.closest('.item-card');
                if (container) {
                    const detailId = container.getAttribute('data-item-id');
                    this.toggleDetail(`detail-${detailId}`);
                }
            }
        });
    }
    
    private static toggleDetail(detailId: string): void {
        const detailElement = document.getElementById(detailId);
        if (detailElement) {
            // 切换显示/隐藏
            if (detailElement.style.display === 'none') {
                detailElement.style.display = 'block';
                detailElement.classList.add('active');
            } else {
                detailElement.style.display = 'none';
                detailElement.classList.remove('active');
            }
            
            // 或者使用CSS类控制
            // detailElement.classList.toggle('show');
        } else {
            console.error(`Detail element not found: ${detailId}`);
        }
    }
    
    // 如果需要只显示一个，隐藏其他
    static toggleExclusive(detailId: string): void {
        // 隐藏所有详情块
        document.querySelectorAll('.detail-content').forEach(element => {
            (element as HTMLElement).style.display = 'none';
            element.classList.remove('active');
        });
        
        // 显示点击的详情块
        const detailElement = document.getElementById(detailId);
        if (detailElement) {
            detailElement.style.display = 'block';
            detailElement.classList.add('active');
        }
    }
}
```

3.2 在 TypeScript 中初始化

```typescript
// main.ts
import { DetailToggle } from './detail-toggle';

document.addEventListener('DOMContentLoaded', () => {
    DetailToggle.init();
    
    // 或者为每个按钮单独绑定（不推荐，但有时需要）
    this.bindIndividualButtons();
});

function bindIndividualButtons(): void {
    // 查找所有切换按钮
    const buttons = document.querySelectorAll('.toggle-detail-btn');
    
    buttons.forEach((button, index) => {
        button.addEventListener('click', function(this: HTMLElement, event) {
            event.preventDefault();
            
            // 方法1: 使用 data 属性
            const targetId = this.getAttribute('data-target');
            if (targetId) {
                const detail = document.getElementById(targetId);
                if (detail) {
                    detail.style.display = detail.style.display === 'none' ? 'block' : 'none';
                }
            }
            
            // 方法2: 查找相邻的详情块
            const container = this.closest('.item-card');
            if (container) {
                const detail = container.querySelector('.detail-content');
                if (detail) {
                    (detail as HTMLElement).classList.toggle('show');
                }
            }
        });
    });
}
```

4. 使用 Thymeleaf 内联 JavaScript（简单场景）

4.1 内联方案

```html
<div th:each="item, iterStat : ${items}">
    <button th:onclick="|toggleDetail('detail-${item.id}')|">
        显示详情
    </button>
    
    <div th:id="'detail-' + ${item.id}" 
         style="display: none;"
         th:with="currentItem=${item}">
        <!-- 使用 th:with 传递变量到片段 -->
        <div th:insert="~{fragments/detail :: content(currentItem=${currentItem})}"></div>
    </div>
</div>

<script th:inline="javascript">
/*<![CDATA[*/
    function toggleDetail(detailId) {
        const element = document.getElementById(detailId);
        if (element) {
            element.style.display = element.style.display === 'none' ? 'block' : 'none';
        }
    }
/*]]>*/
</script>
```

5. CSS 样式配合

5.1 使用 CSS 控制显示

```css
/* style.css */
.detail-content {
    display: none;
    opacity: 0;
    transform: translateY(-10px);
    transition: opacity 0.3s, transform 0.3s;
}

.detail-content.show {
    display: block;
    opacity: 1;
    transform: translateY(0);
}

/* 使用数据属性选择器 */
[data-detail-state="visible"] .detail-content {
    display: block;
}

/* 动画效果 */
@keyframes slideDown {
    from {
        opacity: 0;
        transform: translateY(-10px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

.detail-content.animate {
    animation: slideDown 0.3s ease-out;
}
```

6. 更高级的组件化方案

6.1 创建可复用的 Vue/React 风格组件

```typescript
// ItemDetailComponent.ts
class ItemDetailComponent {
    private container: HTMLElement;
    private itemId: string;
    private detailElement: HTMLElement | null;
    private isVisible: boolean = false;
    
    constructor(container: HTMLElement) {
        this.container = container;
        this.itemId = container.getAttribute('data-item-id') || '';
        this.detailElement = container.querySelector('.detail-content');
        this.init();
    }
    
    private init(): void {
        const toggleBtn = this.container.querySelector('.detail-toggle');
        if (toggleBtn) {
            toggleBtn.addEventListener('click', () => this.toggle());
        }
    }
    
    public toggle(): void {
        if (!this.detailElement) return;
        
        this.isVisible = !this.isVisible;
        
        if (this.isVisible) {
            this.detailElement.classList.add('show');
            this.detailElement.style.display = 'block';
            // 可以在这里加载动态内容
            this.loadDetailContent();
        } else {
            this.detailElement.classList.remove('show');
            this.detailElement.style.display = 'none';
        }
    }
    
    private async loadDetailContent(): Promise<void> {
        if (!this.detailElement || !this.itemId) return;
        
        try {
            const response = await fetch(`/api/items/${this.itemId}/details`);
            const data = await response.json();
            
            // 更新详情内容
            this.detailElement.innerHTML = this.renderDetail(data);
        } catch (error) {
            console.error('Failed to load detail:', error);
        }
    }
    
    private renderDetail(data: any): string {
        return `
            <div class="detail-content-inner">
                <h3>${data.title}</h3>
                <p>${data.description}</p>
                <p>价格: ¥${data.price}</p>
            </div>
        `;
    }
}

// 初始化所有组件
export function initItemDetails(): void {
    document.querySelectorAll('[data-component="item-detail"]').forEach(container => {
        new ItemDetailComponent(container as HTMLElement);
    });
}
```

7. Kotlin 后端支持

7.1 控制器提供详情数据

```kotlin
@RestController
@RequestMapping("/api/items")
class ItemDetailController {
    
    @GetMapping("/{id}/details")
    fun getItemDetails(@PathVariable id: Long): ResponseEntity<ItemDetailDto> {
        val item = itemService.findById(id)
        val detailDto = ItemDetailDto(
            id = item.id,
            title = item.name,
            description = item.description,
            price = item.price,
            createdAt = item.createdAt
        )
        return ResponseEntity.ok(detailDto)
    }
}
```

8. 调试技巧

8.1 添加调试信息

```typescript
// debug.ts
export function debugDetailElements(): void {
    const items = document.querySelectorAll('.item-card');
    
    items.forEach((item, index) => {
        console.group(`Item ${index + 1}`);
        console.log('Item ID:', item.getAttribute('data-item-id'));
        console.log('Detail ID:', `detail-${item.getAttribute('data-item-id')}`);
        
        const detailElement = item.querySelector('.detail-content');
        console.log('Detail Element Found:', !!detailElement);
        console.log('Detail Display:', (detailElement as HTMLElement)?.style.display);
        console.groupEnd();
    });
}
```

8.2 事件监听调试

```javascript
// 检查事件绑定
document.querySelectorAll('.toggle-detail-btn').forEach((btn, i) => {
    const events = getEventListeners(btn); // Chrome DevTools 功能
    console.log(`Button ${i} events:`, events);
});
```

推荐的最佳实践

1. 首选方案：使用 data-* 属性 + 事件委托
2. 确保唯一性：每个元素必须有唯一的 ID 或 data 属性
3. 避免内联事件处理器：使用事件委托提高性能
4. 分离关注点：将 HTML、CSS、JavaScript 分离
5. 使用 TypeScript：获得更好的类型检查和代码提示

关键点：问题通常是因为多个元素共享相同的 ID 或 JavaScript 闭包中引用了错误的变量。通过为每个块生成唯一标识符，并在事件处理时引用正确的标识符，可以解决这个问题。