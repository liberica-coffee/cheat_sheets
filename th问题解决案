这个问题通常是由于 DOM 元素 ID 重复 或 JavaScript 事件绑定问题 导致的。下面我提供几种解决方案：

问题场景分析

```html
<div th:each="item, iter : ${items}" th:id="'item-' + ${iter.index}">
    <h3 th:text="${item.name}"></h3>
    
    <!-- 每个item有自己的按钮 -->
    <button th:id="'btn-' + ${iter.index}" 
            onclick="showDetails(${iter.index})">
        显示详情
    </button>
    
    <!-- 要插入内容的容器 -->
    <div th:id="'details-' + ${iter.index}" class="details-container">
        <!-- 内容将通过 th:insert 或 JavaScript 插入 -->
    </div>
</div>
```

解决方案

方案1：使用唯一标识符和正确的事件处理

```html
<!-- 模板 -->
<script type="text/javascript" th:inline="javascript">
    /*<![CDATA[*/
    // 在页面加载时初始化
    document.addEventListener('DOMContentLoaded', function() {
        // 为所有详情按钮添加事件监听器
        document.querySelectorAll('.detail-btn').forEach(function(btn) {
            btn.addEventListener('click', function() {
                var itemId = this.getAttribute('data-item-id');
                showDetails(itemId);
            });
        });
    });
    
    function showDetails(itemId) {
        // 根据 itemId 获取对应的容器
        var container = document.getElementById('details-' + itemId);
        
        // 如果已经显示，则隐藏；否则显示
        if (container.style.display === 'block') {
            container.style.display = 'none';
        } else {
            // 先隐藏所有详情容器
            document.querySelectorAll('.details-container').forEach(function(el) {
                el.style.display = 'none';
            });
            
            // 显示当前容器
            container.style.display = 'block';
            
            // 如果容器内容为空，则加载内容
            if (container.innerHTML.trim() === '') {
                loadDetails(itemId, container);
            }
        }
    }
    
    function loadDetails(itemId, container) {
        // 使用 AJAX 加载详情
        fetch('/api/items/' + itemId + '/details')
            .then(response => response.text())
            .then(html => {
                container.innerHTML = html;
            })
            .catch(error => {
                console.error('Error loading details:', error);
                container.innerHTML = '<p>加载失败</p>';
            });
    }
    /*]]>*/
</script>

<!-- HTML 部分 -->
<div th:each="item, iter : ${items}" th:id="'item-' + ${iter.index}">
    <h3 th:text="${item.name}"></h3>
    
    <!-- 使用 data-* 属性存储唯一标识 -->
    <button class="detail-btn" 
            th:attr="data-item-id=${item.id}">
        显示详情
    </button>
    
    <!-- 每个容器都有唯一的ID -->
    <div th:id="'details-' + ${item.id}" 
         class="details-container" 
         style="display: none;">
        <!-- 内容将通过AJAX加载 -->
    </div>
</div>
```

方案2：使用 Thymeleaf 内联和模板片段

```html
<!-- 主模板 -->
<div th:each="item : ${items}" th:id="'item-' + ${item.id}">
    <h3 th:text="${item.name}"></h3>
    
    <!-- 点击时加载片段 -->
    <button th:onclick="'loadFragment(\'' + ${item.id} + '\')'">
        显示详情
    </button>
    
    <!-- 容器 -->
    <div th:id="'container-' + ${item.id}"></div>
</div>

<!-- 定义片段模板（可以放在单独的页面中） -->
<div th:fragment="item-details" th:id="details-template" style="display: none;">
    <div class="details-content">
        <h4>详细信息</h4>
        <p>ID: <span th:text="${item.id}"></span></p>
        <p>名称: <span th:text="${item.name}"></span></p>
        <!-- 更多详情 -->
    </div>
</div>

<script type="text/javascript" th:inline="javascript">
    /*<![CDATA[*/
    function loadFragment(itemId) {
        // 获取当前项目的容器
        var container = document.getElementById('container-' + itemId);
        
        // 如果已经有内容，切换显示/隐藏
        if (container.hasChildNodes()) {
            container.style.display = container.style.display === 'none' ? 'block' : 'none';
            return;
        }
        
        // 使用 AJAX 获取片段
        fetch('/fragments/item-details/' + itemId)
            .then(response => response.text())
            .then(html => {
                container.innerHTML = html;
                container.style.display = 'block';
            });
    }
    /*]]>*/
</script>
```

方案3：使用纯 Thymeleaf 方式（无 JavaScript）

```html
<!-- Controller 中处理 -->
@GetMapping("/items")
fun getItems(model: Model): String {
    val items = itemService.findAll()
    items.forEach { item ->
        // 为每个 item 添加展开状态标识
        item.expanded = false
    }
    model.addAttribute("items", items)
    return "items/list"
}

@PostMapping("/items/{id}/toggle")
fun toggleItem(@PathVariable id: Long, model: Model): String {
    val items = itemService.findAll()
    items.forEach { item ->
        // 切换展开状态
        item.expanded = item.id == id && !item.expanded
    }
    model.addAttribute("items", items)
    return "items/list :: #items-container"  // 只更新容器部分
}
```

```html
<!-- HTML 模板 -->
<div id="items-container">
    <div th:each="item : ${items}" class="item-card">
        <div class="item-header">
            <h3 th:text="${item.name}"></h3>
            
            <!-- 表单提交切换状态 -->
            <form th:action="@{/items/{id}/toggle(id=${item.id})}" 
                  th:method="post"
                  style="display: inline;">
                <button type="submit">
                    <span th:text="${item.expanded} ? '收起' : '展开'"></span>
                </button>
            </form>
        </div>
        
        <!-- 根据 expanded 状态显示/隐藏详情 -->
        <div th:if="${item.expanded}" class="item-details">
            <p>ID: <span th:text="${item.id}"></span></p>
            <p>描述: <span th:text="${item.description}"></span></p>
            <p>价格: <span th:text="${#numbers.formatCurrency(item.price)}"></span></p>
            
            <!-- 嵌套内容 -->
            <div th:if="${item.subItems}" class="sub-items">
                <h4>子项目</h4>
                <div th:each="subItem : ${item.subItems}">
                    <span th:text="${subItem.name}"></span>
                </div>
            </div>
        </div>
    </div>
</div>
```

方案4：使用事件委托和 Bootstrap（如果使用）

```html
<!-- 使用 Bootstrap 折叠组件 -->
<div th:each="item : ${items}" class="accordion-item">
    <h2 class="accordion-header" th:id="'heading-' + ${item.id}">
        <button class="accordion-button collapsed" 
                type="button" 
                data-bs-toggle="collapse"
                th:attr="data-bs-target='#collapse-' + ${item.id}"
                aria-expanded="false"
                th:attr="aria-controls='collapse-' + ${item.id}">
            <span th:text="${item.name}"></span>
        </button>
    </h2>
    
    <div th:id="'collapse-' + ${item.id}"
         class="accordion-collapse collapse"
         th:attr="aria-labelledby='heading-' + ${item.id}"
         data-bs-parent="#itemsAccordion">
        <div class="accordion-body">
            <!-- 每个项目的独立内容 -->
            <p th:text="${item.description}"></p>
            <p>价格: <span th:text="${#numbers.formatCurrency(item.price)}"></span></p>
            
            <!-- 嵌套循环也不会冲突 -->
            <div th:if="${item.features}" class="mt-3">
                <h6>特性：</h6>
                <ul>
                    <li th:each="feature : ${item.features}"
                        th:text="${feature}"></li>
                </ul>
            </div>
        </div>
    </div>
</div>
```

方案5：使用 Vue.js 或 React 与 Thymeleaf 集成

```html
<!-- 使用 Vue.js 处理交互 -->
<div id="app">
    <div v-for="(item, index) in items" :key="item.id" class="item">
        <h3>{{ item.name }}</h3>
        
        <button @click="toggleDetails(index)">
            {{ item.showDetails ? '收起' : '显示' }}详情
        </button>
        
        <div v-if="item.showDetails" class="details">
            <!-- 从 Thymeleaf 传递初始数据 -->
            <div th:each="detail : ${initialDetails}" 
                 v-if="detail.itemId === item.id">
                <p th:text="${detail.content}"></p>
            </div>
            
            <!-- 或者通过 AJAX 加载 -->
            <div v-if="item.details">
                <p v-for="detail in item.details">{{ detail }}</p>
            </div>
        </div>
    </div>
</div>

<script th:inline="javascript">
    /*<![CDATA[*/
    new Vue({
        el: '#app',
        data: {
            items: /*[[${items}]]*/ []
        },
        methods: {
            toggleDetails(index) {
                // 切换显示状态
                this.items[index].showDetails = !this.items[index].showDetails;
                
                // 如果需要，加载详情数据
                if (this.items[index].showDetails && !this.items[index].details) {
                    this.loadDetails(index);
                }
            },
            loadDetails(index) {
                var itemId = this.items[index].id;
                fetch('/api/items/' + itemId + '/details')
                    .then(response => response.json())
                    .then(data => {
                        Vue.set(this.items[index], 'details', data);
                    });
            }
        },
        mounted() {
            // 初始化显示状态
            this.items.forEach(item => {
                Vue.set(item, 'showDetails', false);
            });
        }
    });
    /*]]>*/
</script>
```

关键要点总结

1. 唯一标识符：确保每个元素的 ID 是唯一的，使用 th:id="'prefix-' + ${item.id}"
2. 正确的事件绑定：
   · 避免使用 onclick="function(${iter.index})"，因为循环中的索引可能有问题
   · 使用 data-* 属性存储标识：th:attr="data-item-id=${item.id}"
3. 事件委托：使用事件委托处理动态生成的元素
4. 状态管理：在数据层管理展开/收起状态
5. AJAX 加载：对于复杂内容，使用 AJAX 按需加载
6. 框架集成：考虑使用 Vue/React 处理复杂交互，Thymeleaf 负责初始渲染

最常见的问题是 ID 冲突 和 事件处理函数中的变量作用域问题。建议使用方案1或方案2，它们能有效解决你的问题。